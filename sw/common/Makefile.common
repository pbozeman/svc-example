#
# Common Makefile rules for RISC-V software builds
#
# Include this from individual program Makefiles
#

# Toolchain configuration
CROSS_COMPILE ?= riscv64-none-elf-
CC      = $(CROSS_COMPILE)gcc
AS      = $(CROSS_COMPILE)as
LD      = $(CROSS_COMPILE)ld
OBJCOPY = $(CROSS_COMPILE)objcopy
OBJDUMP = $(CROSS_COMPILE)objdump
SIZE    = $(CROSS_COMPILE)size

# Directories
SW_ROOT  ?= ..
SW_COMMON = $(SW_ROOT)/common
RV_ARCH ?= rv32i
BUILD_DIR = $(SW_ROOT)/../.build/sw/$(RV_ARCH)/$(PROGRAM)
LIBSVC_DIR = $(SW_COMMON)/libsvc

# Project root for dependency file generation
# Convert BUILD_DIR paths to be relative to project root for .d files
PROJECT_ROOT = $(abspath $(SW_ROOT)/..)

# Architecture flags (32-bit RISC-V with Zicsr for CSR access)
ARCH_FLAGS = -march=$(RV_ARCH)_zicsr -mabi=ilp32

# Conditional libgcc for soft multiply
# RV32I: Needs libgcc for software multiply (division provided by libsvc)
# RV32IM: Uses hardware mul/div, no libgcc needed
ifeq ($(RV_ARCH),rv32i)
  LIBGCC = -lgcc
else
  LIBGCC =
endif

# Compiler flags
CFLAGS = $(ARCH_FLAGS) \
         -O2 \
         -g \
         -Wall \
         -Wextra \
         -ffreestanding \
         -nostdlib \
         -nostartfiles \
         -I$(SW_COMMON) \
         -I$(LIBSVC_DIR)

# Assembler flags
ASFLAGS = $(ARCH_FLAGS)

# Linker flags
LDFLAGS = $(ARCH_FLAGS) \
          -T$(SW_COMMON)/link.ld \
          -nostdlib \
          -nostartfiles \
          -Wl,--gc-sections

# Common source files
CRT0_S = $(SW_COMMON)/crt0.S

# libsvc library
LIBSVC_SRC = $(wildcard $(LIBSVC_DIR)/*.c)
LIBSVC_ASM = $(wildcard $(LIBSVC_DIR)/*.S)
LIBSVC_OBJ = $(patsubst $(LIBSVC_DIR)/%.c,$(BUILD_DIR)/libsvc/%.o,$(LIBSVC_SRC)) \
             $(patsubst $(LIBSVC_DIR)/%.S,$(BUILD_DIR)/libsvc/%.o,$(LIBSVC_ASM))
LIBSVC_A = $(BUILD_DIR)/libsvc.a

# Build outputs with paths
BUILD_OBJS = $(addprefix $(BUILD_DIR)/,$(OBJS))
CRT0_O = $(BUILD_DIR)/crt0.o
ELF = $(BUILD_DIR)/$(PROGRAM).elf
BIN = $(BUILD_DIR)/$(PROGRAM).bin
HEX = $(BUILD_DIR)/$(PROGRAM).hex
DIS = $(BUILD_DIR)/$(PROGRAM).dis

# Note: .hex.d dependency files are included by top-level Makefile (svc/mk/sim.mk)
# not here, since paths in .d files are relative to project root

# Default target
.PHONY: all
all: $(ELF) $(HEX) $(DIS)

# Create build directory
$(BUILD_DIR):
	@mkdir -p $(BUILD_DIR)

# Compile C sources
$(BUILD_DIR)/%.o: %.c | $(BUILD_DIR)
	$(CC) $(CFLAGS) -c -o $@ $<

# Assemble startup code
$(CRT0_O): $(CRT0_S) | $(BUILD_DIR)
	$(CC) $(ASFLAGS) -c -o $@ $<

# Build libsvc directory
$(BUILD_DIR)/libsvc:
	@mkdir -p $@

# Compile libsvc sources
$(BUILD_DIR)/libsvc/%.o: $(LIBSVC_DIR)/%.c | $(BUILD_DIR)/libsvc
	$(CC) $(CFLAGS) -c -o $@ $<

# Assemble libsvc assembly sources
$(BUILD_DIR)/libsvc/%.o: $(LIBSVC_DIR)/%.S | $(BUILD_DIR)/libsvc
	$(CC) $(ASFLAGS) -c -o $@ $<

# Archive libsvc library
$(LIBSVC_A): $(LIBSVC_OBJ)
	$(AR) rcs $@ $^

# Link ELF
$(ELF): $(BUILD_OBJS) $(CRT0_O) $(LIBSVC_A)
	$(CC) $(LDFLAGS) -o $@ $(CRT0_O) $(BUILD_OBJS) $(LIBSVC_A) $(LIBGCC)
	$(SIZE) $@

# Generate binary
$(BIN): $(ELF)
	$(OBJCOPY) -O binary $< $@

# Generate Verilog hex format for $readmemh
# Convert to binary then to hex format (32-bit words, one per line)
$(HEX): $(ELF)
	$(OBJCOPY) -O binary $< $@.tmp
	od -An -tx4 -w4 -v $@.tmp | sed 's/^ *//' > $@
	rm -f $@.tmp
	@echo "$(patsubst $(PROJECT_ROOT)/%,%,$(abspath $@)): $(abspath $(CRT0_S)) $(abspath $(wildcard *.c))" > $@.d

# Generate disassembly
$(DIS): $(ELF)
	$(OBJDUMP) -d $< > $@

# Clean
.PHONY: clean
clean:
	rm -rf $(BUILD_DIR)

# Display hex file (useful for debugging)
.PHONY: show
show: $(HEX)
	@echo "=== $(PROGRAM).hex ==="
	@cat $(HEX)
