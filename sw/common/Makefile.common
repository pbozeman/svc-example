#
# Common Makefile rules for RISC-V software builds
#
# Include this from individual program Makefiles
#

# Toolchain configuration
CROSS_COMPILE ?= riscv64-none-elf-
CC      = $(CROSS_COMPILE)gcc
AS      = $(CROSS_COMPILE)as
LD      = $(CROSS_COMPILE)ld
OBJCOPY = $(CROSS_COMPILE)objcopy
OBJDUMP = $(CROSS_COMPILE)objdump
SIZE    = $(CROSS_COMPILE)size

# Directories
SW_ROOT  ?= ..
SW_COMMON = $(SW_ROOT)/common
RV_ARCH ?= rv32i
BUILD_DIR = $(SW_ROOT)/../.build/sw/$(RV_ARCH)/$(PROGRAM)
LIBSVC_DIR = $(SW_COMMON)/libsvc

# Project root for dependency file generation
# Convert BUILD_DIR paths to be relative to project root for .d files
PROJECT_ROOT = $(abspath $(SW_ROOT)/..)

# Architecture flags (32-bit RISC-V with Zicsr for CSR access)
ARCH_FLAGS = -march=$(RV_ARCH)_zicsr -mabi=ilp32

# Conditional libgcc for soft multiply
# RV32I: Needs libgcc for software multiply (division provided by libsvc)
# RV32IM: Uses hardware mul/div, no libgcc needed
ifeq ($(RV_ARCH),rv32i)
  LIBGCC = -lgcc
else
  LIBGCC =
endif

# Compiler flags
CFLAGS = $(ARCH_FLAGS) \
         -O2 \
         -g \
         -Wall \
         -Wextra \
         -ffreestanding \
         -nostdlib \
         -nostartfiles \
         -I$(SW_COMMON) \
         -I$(LIBSVC_DIR)

ifdef SVC_DISABLE_MMIO
  CFLAGS += -DSVC_DISABLE_MMIO
endif

# Assembler flags
ASFLAGS = $(ARCH_FLAGS)

# Memory configuration from top-level Makefile
# Convert word counts to byte sizes for linker
# IMEM and DMEM depths are in 32-bit words, linker needs bytes
PROG_IMEM_DEPTH := $(if $($(PROGRAM)_RV_IMEM_DEPTH),$($(PROGRAM)_RV_IMEM_DEPTH),$(RV_IMEM_DEPTH))
PROG_DMEM_DEPTH := $(if $($(PROGRAM)_RV_DMEM_DEPTH),$($(PROGRAM)_RV_DMEM_DEPTH),$(RV_DMEM_DEPTH))
IMEM_SIZE_BYTES := $(shell echo $$(($(PROG_IMEM_DEPTH) * 4)))
DMEM_SIZE_BYTES := $(shell echo $$(($(PROG_DMEM_DEPTH) * 4)))

# Linker flags
LDFLAGS = $(ARCH_FLAGS) \
          -T$(SW_COMMON)/link.ld \
          -nostdlib \
          -nostartfiles \
          -Wl,--gc-sections \
          -Wl,--defsym,__imem_size=$(IMEM_SIZE_BYTES) \
          -Wl,--defsym,__dmem_size=$(DMEM_SIZE_BYTES)

# Common source files
CRT0_S = $(SW_COMMON)/crt0.S

# libsvc library - shared per architecture
LIBSVC_BUILD_DIR = $(SW_ROOT)/../.build/sw/$(RV_ARCH)/lib
LIBSVC_SRC = $(wildcard $(LIBSVC_DIR)/*.c)
LIBSVC_ASM = $(wildcard $(LIBSVC_DIR)/*.S)
LIBSVC_OBJ = $(patsubst $(LIBSVC_DIR)/%.c,$(LIBSVC_BUILD_DIR)/%.o,$(LIBSVC_SRC)) \
             $(patsubst $(LIBSVC_DIR)/%.S,$(LIBSVC_BUILD_DIR)/%.o,$(LIBSVC_ASM))
LIBSVC_A = $(LIBSVC_BUILD_DIR)/libsvc.a

# Library compilation flags - aggressive optimization for all programs
# Libraries are external dependencies, not subject to program-specific rules
# Use SVC_DISABLE_MMIO=1 to build with deterministic stubs (no I/O)
LIBSVC_EXTRA_CFLAGS ?=
ifdef SVC_DISABLE_MMIO
  LIBSVC_EXTRA_CFLAGS += -DSVC_DISABLE_MMIO
endif
LIBSVC_CFLAGS ?= $(ARCH_FLAGS) -O3 -funroll-loops -flto -ffat-lto-objects \
                 -Wall -Wextra -ffreestanding -nostdlib -nostartfiles \
                 -I$(SW_COMMON) -I$(LIBSVC_DIR) $(LIBSVC_EXTRA_CFLAGS)

# Build outputs with paths
BUILD_OBJS = $(addprefix $(BUILD_DIR)/,$(OBJS))
CRT0_O = $(BUILD_DIR)/crt0.o
ELF = $(BUILD_DIR)/$(PROGRAM).elf
BIN = $(BUILD_DIR)/$(PROGRAM).bin
HEX = $(BUILD_DIR)/$(PROGRAM).hex
HEX128 = $(BUILD_DIR)/$(PROGRAM)_128.hex
DIS = $(BUILD_DIR)/$(PROGRAM).dis

# Note: .hex.d dependency files are included by top-level Makefile (svc/mk/sim.mk)
# not here, since paths in .d files are relative to project root

# Default target
.PHONY: all
all: $(ELF) $(HEX) $(HEX128) $(DIS)

# Explicit libsvc target
.PHONY: libsvc
libsvc: $(LIBSVC_A)

# Create build directory
$(BUILD_DIR):
	@mkdir -p $(BUILD_DIR)

# Compile C sources
$(BUILD_DIR)/%.o: %.c | $(BUILD_DIR)
	$(CC) $(CFLAGS) -c -o $@ $<

# Assemble startup code
$(CRT0_O): $(CRT0_S) | $(BUILD_DIR)
	$(CC) $(ASFLAGS) -c -o $@ $<

# Build libsvc directory
$(LIBSVC_BUILD_DIR):
	@mkdir -p $@

# Compile libsvc sources (using LIBSVC_CFLAGS for aggressive optimization)
$(LIBSVC_BUILD_DIR)/%.o: $(LIBSVC_DIR)/%.c | $(LIBSVC_BUILD_DIR)
	$(CC) $(LIBSVC_CFLAGS) -c -o $@ $<

# Assemble libsvc assembly sources
$(LIBSVC_BUILD_DIR)/%.o: $(LIBSVC_DIR)/%.S | $(LIBSVC_BUILD_DIR)
	$(CC) $(ASFLAGS) -c -o $@ $<

# Archive libsvc library
$(LIBSVC_A): $(LIBSVC_OBJ)
	$(AR) rcs $@ $^

# Link ELF
$(ELF): $(BUILD_OBJS) $(CRT0_O) $(LIBSVC_A)
	$(CC) $(LDFLAGS) -o $@ $(CRT0_O) $(BUILD_OBJS) $(LIBSVC_A) $(LIBGCC)
	$(SIZE) $@

# Generate binary
$(BIN): $(ELF)
	$(OBJCOPY) -O binary $< $@

# Generate Verilog hex format for $readmemh
# Convert to binary then to hex format (32-bit words, one per line)
$(HEX): $(ELF)
	$(OBJCOPY) -O binary $< $@.tmp
	od -An -tx4 -w4 -v $@.tmp | sed 's/^ *//' > $@
	rm -f $@.tmp
	@echo "$(patsubst $(PROJECT_ROOT)/%,%,$(abspath $@)): $(abspath $(CRT0_S)) $(abspath $(wildcard *.c))" > $@.d

# Generate 128-bit hex format for AXI memory (4 words per line, little-endian)
# Pack 4 consecutive 32-bit words: word3 word2 word1 word0 -> 128-bit line
$(HEX128): $(HEX)
	@awk 'BEGIN { i=0 } { w[i++]=$$0 } END { \
		for(j=0; j<i; j+=4) { \
			printf "%s%s%s%s\n", \
				(j+3<i ? w[j+3] : "00000000"), \
				(j+2<i ? w[j+2] : "00000000"), \
				(j+1<i ? w[j+1] : "00000000"), \
				w[j] \
		} \
	}' $< > $@

# Generate disassembly
$(DIS): $(ELF)
	$(OBJDUMP) -d $< > $@

# Clean
.PHONY: clean
clean:
	rm -rf $(BUILD_DIR)

# Display hex file (useful for debugging)
.PHONY: show
show: $(HEX)
	@echo "=== $(PROGRAM).hex ==="
	@cat $(HEX)
